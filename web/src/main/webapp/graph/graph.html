<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<header>
	<script src="../js/Chart.bundle.js">
	</script>
	<script src="../js/chartjs-plugin-datalabels.min.js">
	</script>
	<script>
	Chart.pluginService.register({
	    beforeRender: function (chart) {
	        if (chart.config.options.showAllTooltips) {
	            // create an array of tooltips
	            // we can't use the chart tooltip because there is only one tooltip per chart
	            chart.pluginTooltips = [];
	            chart.config.data.datasets.forEach(function (dataset, i) {
	                chart.getDatasetMeta(i).data.forEach(function (sector, j) {
	                    chart.pluginTooltips.push(new Chart.Tooltip({
	                        _chart: chart.chart,
	                        _chartInstance: chart,
	                        _data: chart.data,
	                        _options: chart.options,
	                        _active: [sector]
	                    }, chart));
	                });
	            });

	            // turn off normal tooltips
	            chart.options.tooltips.enabled = false;
	        }
	    },
	    afterDraw: function (chart, easing) {
	        if (chart.config.options.showAllTooltips) {
	            // we don't want the permanent tooltips to animate, so don't do anything till the animation runs atleast once
	            if (!chart.allTooltipsOnce) {
	                if (easing !== 1)
	                    return;
	                chart.allTooltipsOnce = true;
	            }

	            // turn on tooltips
	            chart.options.tooltips.enabled = true;
	            Chart.helpers.each(chart.pluginTooltips, function (tooltip) {
	                tooltip.initialize();
	                tooltip.update();
	                // we don't actually need this since we are not animating tooltips
	                tooltip.pivot();
	                tooltip.transition(easing).draw();
	            });
	            chart.options.tooltips.enabled = false;
	        }
	    }
	});

	Chart.pluginService.register({
		  beforeDraw: function(chart) {
		    if (chart.config.options.elements.center) {
		      // Get ctx from string
		      var ctx = chart.chart.ctx;

		      // Get options from the center object in options
		      var centerConfig = chart.config.options.elements.center;
		      var fontStyle = centerConfig.fontStyle || 'Arial';
		      var txt = centerConfig.text;
		      var color = centerConfig.color || '#000';
		      var maxFontSize = centerConfig.maxFontSize || 75;
		      var sidePadding = centerConfig.sidePadding || 20;
		      var sidePaddingCalculated = (sidePadding / 100) * (chart.innerRadius * 2)
		      // Start with a base font of 30px
		      ctx.font = "30px " + fontStyle;

		      // Get the width of the string and also the width of the element minus 10 to give it 5px side padding
		      var stringWidth = ctx.measureText(txt).width;
		      var elementWidth = (chart.innerRadius * 2) - sidePaddingCalculated;

		      // Find out how much the font can grow in width.
		      var widthRatio = elementWidth / stringWidth;
		      var newFontSize = Math.floor(30 * widthRatio);
		      var elementHeight = (chart.innerRadius * 2);

		      // Pick a new font size so it will not be larger than the height of label.
		      var fontSizeToUse = Math.min(newFontSize, elementHeight, maxFontSize);
		      var minFontSize = centerConfig.minFontSize;
		      var lineHeight = centerConfig.lineHeight || 25;
		      var wrapText = false;

		      if (minFontSize === undefined) {
		        minFontSize = 20;
		      }

		      if (minFontSize && fontSizeToUse < minFontSize) {
		        fontSizeToUse = minFontSize;
		        wrapText = true;
		      }

		      // Set font settings to draw it correctly.
		      ctx.textAlign = 'center';
		      ctx.textBaseline = 'middle';
		      var centerX = ((chart.chartArea.left + chart.chartArea.right) / 2);
		      var centerY = ((chart.chartArea.top + chart.chartArea.bottom) / 2);
		      ctx.font = fontSizeToUse + "px " + fontStyle;
		      ctx.fillStyle = color;

		      if (!wrapText) {
		        ctx.fillText(txt, centerX, centerY);
		        return;
		      }

		      var words = txt.split(' ');
		      var line = '';
		      var lines = [];

		      // Break words up into multiple lines if necessary
		      for (var n = 0; n < words.length; n++) {
		        var testLine = line + words[n] + ' ';
		        var metrics = ctx.measureText(testLine);
		        var testWidth = metrics.width;
		        if (testWidth > elementWidth && n > 0) {
		          lines.push(line);
		          line = words[n] + ' ';
		        } else {
		          line = testLine;
		        }
		      }

		      // Move the center up depending on line height and number of lines
		      centerY -= (lines.length / 2) * lineHeight;

		      for (var n = 0; n < lines.length; n++) {
		        ctx.fillText(lines[n], centerX, centerY);
		        centerY += lineHeight;
		      }
		      //Draw text in center
		      ctx.fillText(line, centerX, centerY);
		    }
		  }
		});
	
	var myChart = null;
	var myData = null;
	
	async function loadData () 
    {
		var url = document.location.href;
		var i  = url.indexOf("?data=");
		var dataPath = url.substring(i+6);
        const response = await fetch("./"+dataPath, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        });
        myData = await response.json();
        if (myData.options && myData.options.scales && 
        		myData.options.scales.yAxes &&
        		myData.options.scales.yAxes[0] &&
        		myData.options.scales.yAxes[0].ticks &&
        		myData.options.scales.yAxes[0].ticks.callback &&
        		myData.options.scales.yAxes[0].ticks.callback == "locale")
      		{
        	myData.options.scales.yAxes[0].ticks.callback = 
   	   			function(value, index, values) {
						return value.toLocaleString(); 
				};
      		}
        var chart = document.getElementById('myChart');
		var ctx = chart.getContext('2d');

		if (myChart) {
			myChart.data = myData.data;
			myChart.options = myData.options;
			myChart.update();
//			myChart.destroy();
		} else {
			chart.style.width="90vw";
			chart.style.height="90vh";
			chart.width = chart.offsetWidth;
			chart.height = chart.offsetHeight;
			myChart = new Chart(ctx, myData);
			chart.width = chart.offsetWidth;
			chart.height = chart.offsetHeight;
    	}
		if ( myData.refresh) {
			setTimeout ( loadData, myData.refresh );
		}
        return myData;
    }

	window.addEventListener("resize", (event) => {
		if (myData != null) {
	        var chart = document.getElementById('myChart');
			chart.style.width="90vw";
			chart.style.height="90vh";
			chart.width = chart.offsetWidth;
			chart.height = chart.offsetHeight;
			var ctx = chart.getContext('2d');
		console.log("On resize "+chart.width+" "+chart.height);
			myChart = new Chart(ctx, myData);
//			chart.width = chart.offsetWidth;
//			chart.height = chart.offsetHeight;
		}
	});
	</script>
</header>
<body onLoad="loadData()" style="overflow: hidden ">
	<canvas id="myChart" style="height: 90vh; width: 90vw"></canvas>
</body>
</html>
